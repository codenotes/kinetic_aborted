.. _moduleTreeCore:

music21.tree.core
=================

.. WARNING: DO NOT EDIT THIS FILE:
   AUTOMATICALLY GENERATED.
   PLEASE EDIT THE .py FILE DIRECTLY.

.. automodule:: music21.tree.core

AVLNode
-------

.. autoclass:: music21.tree.core.AVLNode

.. rubric:: :class:`~music21.tree.core.AVLNode` bases

- :class:`~music21.common.objects.SlottedObjectMixin`

.. rubric:: :class:`~music21.tree.core.AVLNode` methods

.. automethod:: music21.tree.core.AVLNode.debug

.. automethod:: music21.tree.core.AVLNode.moveAttributes

.. automethod:: music21.tree.core.AVLNode.rebalance

.. automethod:: music21.tree.core.AVLNode.rotateLeftLeft

.. automethod:: music21.tree.core.AVLNode.rotateLeftRight

.. automethod:: music21.tree.core.AVLNode.rotateRightLeft

.. automethod:: music21.tree.core.AVLNode.rotateRightRight

.. automethod:: music21.tree.core.AVLNode.update

.. rubric:: :class:`~music21.tree.core.AVLNode` instance variables

.. attribute:: AVLNode.balance

	
	Returns the current state of the difference in heights of the
	two subtrees rooted on this node.
	
	This attribute is used to help balance the AVL tree.
	
	>>> score = tree.makeExampleScore()
	>>> scoreTree = tree.fromStream.asTimespans(score, flatten=True,
	...                    classList=(note.Note, chord.Chord))
	>>> print(scoreTree.debug())
	<OffsetNode: Start:3.0 Indices:(0:5:6:12) Length:{1}>
	L: <OffsetNode: Start:1.0 Indices:(0:2:3:5) Length:{1}>
	L: <OffsetNode: Start:0.0 Indices:(0:0:2:2) Length:{2}>
	R: <OffsetNode: Start:2.0 Indices:(3:3:5:5) Length:{2}>
	R: <OffsetNode: Start:5.0 Indices:(6:8:9:12) Length:{1}>
	L: <OffsetNode: Start:4.0 Indices:(6:6:8:8) Length:{2}>
	R: <OffsetNode: Start:6.0 Indices:(9:9:11:12) Length:{2}>
	R: <OffsetNode: Start:7.0 Indices:(11:11:12:12) Length:{1}>
	
	
	This tree has one more depth on the right than on the left
	
	>>> scoreTree.rootNode.balance
	1
	
	
	The leftChild of the rootNote is perfectly balanced, while the rightChild is off by
	one (acceptable).
	
	>>> scoreTree.rootNode.leftChild.balance
	0
	>>> scoreTree.rootNode.rightChild.balance
	1
	
	
	The rightChild's children are also (acceptably) unbalanced:
	
	>>> scoreTree.rootNode.rightChild.leftChild.balance
	0
	>>> scoreTree.rootNode.rightChild.rightChild.balance
	1
	
	You should never see a balance other than 1, -1, or 0.  If you do then
	something has gone wrong.
	

.. attribute:: AVLNode.height

	
	The height of the subtree rooted on this node.
	
	This property is used to help balance the AVL tree.
	
	>>> score = tree.makeExampleScore()
	>>> scoreTree = tree.fromStream.asTimespans(score, flatten=True,
	...              classList=(note.Note, chord.Chord))
	>>> print(scoreTree.debug())
	<OffsetNode: Start:3.0 Indices:(0:5:6:12) Length:{1}>
	L: <OffsetNode: Start:1.0 Indices:(0:2:3:5) Length:{1}>
	L: <OffsetNode: Start:0.0 Indices:(0:0:2:2) Length:{2}>
	R: <OffsetNode: Start:2.0 Indices:(3:3:5:5) Length:{2}>
	R: <OffsetNode: Start:5.0 Indices:(6:8:9:12) Length:{1}>
	L: <OffsetNode: Start:4.0 Indices:(6:6:8:8) Length:{2}>
	R: <OffsetNode: Start:6.0 Indices:(9:9:11:12) Length:{2}>
	R: <OffsetNode: Start:7.0 Indices:(11:11:12:12) Length:{1}>
	
	>>> scoreTree.rootNode.height
	3
	
	>>> scoreTree.rootNode.rightChild.height
	2
	
	>>> scoreTree.rootNode.rightChild.rightChild.height
	1
	
	>>> scoreTree.rootNode.rightChild.rightChild.rightChild.height
	0
	
	Once you hit a height of zero, then the next child on either size should be None
	
	>>> print(scoreTree.rootNode.rightChild.rightChild.rightChild.rightChild)
	None
	

.. attribute:: AVLNode.leftChild

	
	The left child of this node.
	
	After setting the left child you need to do a node update. with node.update()
	
	>>> score = tree.makeExampleScore()
	>>> scoreTree = tree.fromStream.asTimespans(score, flatten=True,
	...           classList=(note.Note, chord.Chord))
	>>> print(scoreTree.rootNode.debug())
	<OffsetNode: Start:3.0 Indices:(0:5:6:12) Length:{1}>
	L: <OffsetNode: Start:1.0 Indices:(0:2:3:5) Length:{1}>
	L: <OffsetNode: Start:0.0 Indices:(0:0:2:2) Length:{2}>
	R: <OffsetNode: Start:2.0 Indices:(3:3:5:5) Length:{2}>
	R: <OffsetNode: Start:5.0 Indices:(6:8:9:12) Length:{1}>
	L: <OffsetNode: Start:4.0 Indices:(6:6:8:8) Length:{2}>
	R: <OffsetNode: Start:6.0 Indices:(9:9:11:12) Length:{2}>
	R: <OffsetNode: Start:7.0 Indices:(11:11:12:12) Length:{1}>
	
	>>> print(scoreTree.rootNode.leftChild.debug())
	<OffsetNode: Start:1.0 Indices:(0:2:3:5) Length:{1}>
	L: <OffsetNode: Start:0.0 Indices:(0:0:2:2) Length:{2}>
	R: <OffsetNode: Start:2.0 Indices:(3:3:5:5) Length:{2}>
	

.. attribute:: AVLNode.payload

	
	The content of the node at this point.  Usually a Music21Object.
	

.. attribute:: AVLNode.position

	
	The position of this node -- this is often the same as the offset of
	the node in a containing score, but does not need to be. It could be the .sortTuple
	
	>>> score = tree.makeExampleScore()
	>>> scoreTree = tree.fromStream.asTimespans(score, flatten=True,
	...            classList=(note.Note, chord.Chord))
	>>> print(scoreTree.rootNode.debug())
	<OffsetNode: Start:3.0 Indices:(0:5:6:12) Length:{1}>
	L: <OffsetNode: Start:1.0 Indices:(0:2:3:5) Length:{1}>
	L: <OffsetNode: Start:0.0 Indices:(0:0:2:2) Length:{2}>
	R: <OffsetNode: Start:2.0 Indices:(3:3:5:5) Length:{2}>
	R: <OffsetNode: Start:5.0 Indices:(6:8:9:12) Length:{1}>
	L: <OffsetNode: Start:4.0 Indices:(6:6:8:8) Length:{2}>
	R: <OffsetNode: Start:6.0 Indices:(9:9:11:12) Length:{2}>
	R: <OffsetNode: Start:7.0 Indices:(11:11:12:12) Length:{1}>
	
	>>> scoreTree.rootNode.position
	3.0
	
	>>> scoreTree.rootNode.leftChild.position
	1.0
	
	>>> scoreTree.rootNode.rightChild.position
	5.0
	

.. attribute:: AVLNode.rightChild

	
	The right child of this node.
	
	After setting the right child you need to do a node update. with node.update()
	
	>>> score = tree.makeExampleScore()
	>>> scoreTree = tree.fromStream.asTimespans(score, flatten=True,
	...             classList=(note.Note, chord.Chord))
	>>> print(scoreTree.rootNode.debug())
	<OffsetNode: Start:3.0 Indices:(0:5:6:12) Length:{1}>
	L: <OffsetNode: Start:1.0 Indices:(0:2:3:5) Length:{1}>
	L: <OffsetNode: Start:0.0 Indices:(0:0:2:2) Length:{2}>
	R: <OffsetNode: Start:2.0 Indices:(3:3:5:5) Length:{2}>
	R: <OffsetNode: Start:5.0 Indices:(6:8:9:12) Length:{1}>
	L: <OffsetNode: Start:4.0 Indices:(6:6:8:8) Length:{2}>
	R: <OffsetNode: Start:6.0 Indices:(9:9:11:12) Length:{2}>
	R: <OffsetNode: Start:7.0 Indices:(11:11:12:12) Length:{1}>
	
	>>> print(scoreTree.rootNode.rightChild.debug())
	<OffsetNode: Start:5.0 Indices:(6:8:9:12) Length:{1}>
	L: <OffsetNode: Start:4.0 Indices:(6:6:8:8) Length:{2}>
	R: <OffsetNode: Start:6.0 Indices:(9:9:11:12) Length:{2}>
	R: <OffsetNode: Start:7.0 Indices:(11:11:12:12) Length:{1}>
	
	>>> print(scoreTree.rootNode.rightChild.rightChild.debug())
	<OffsetNode: Start:6.0 Indices:(9:9:11:12) Length:{2}>
	R: <OffsetNode: Start:7.0 Indices:(11:11:12:12) Length:{1}>
	
	>>> print(scoreTree.rootNode.rightChild.rightChild.rightChild.debug())
	<OffsetNode: Start:7.0 Indices:(11:11:12:12) Length:{1}>
	

AVLTree
-------

.. autoclass:: music21.tree.core.AVLTree

.. rubric:: :class:`~music21.tree.core.AVLTree` methods

.. automethod:: music21.tree.core.AVLTree.createNodeAtPosition

.. automethod:: music21.tree.core.AVLTree.debug

.. automethod:: music21.tree.core.AVLTree.getNodeAfter

.. automethod:: music21.tree.core.AVLTree.getNodeBefore

.. automethod:: music21.tree.core.AVLTree.getNodeByPosition

.. automethod:: music21.tree.core.AVLTree.getPositionAfter

.. automethod:: music21.tree.core.AVLTree.getPositionBefore

.. automethod:: music21.tree.core.AVLTree.populateFromSortedList

.. automethod:: music21.tree.core.AVLTree.removeNode
